<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>MIDICSV: Convert MIDI File to and from CSV</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="http://www.fourmilab.ch/documents/styles/standard_screen.css" type="text/css" />
<style type="text/css">
    blockquote.listing {
    	background-color: rgb(192, 192, 192);
	font-size: small;
    }
    
    dd {
    	text-align: justify;
    }
    
    sub, sup {
    	line-height: 0px;
    }
</style>
<meta name="keywords" content="midicsv, MIDI, CSV, music, edit, conversion" />
<meta name="description" content="MIDICSV: Convert MIDI File to and from CSV" />
<meta name="author" content="John Walker" />
<meta name="robots" content="index" />
</head>

<body class="standard">

<center>
<h1><img src="figures/midicsv.png" width="640" height="117" alt="MIDICSV" /></h1>
</center>

<hr />

<p class="j">
This page describes, in Unix manual page style,
programs
<a href="#Download">available for downloading</a> from this site
which translate MIDI music files into a human- and computer-readable
CSV (Comma-Separated Value) format, suitable for manipulation
by spreadsheet, database, or text processing utilities, and
re-encoding processed CSV files into MIDI.  No information is
lost in transforming a MIDI file to CSV and back.
</p>

<p class="j">
For decades, MIDI files have been the <em>lingua franca</em> of
electronic musicians.  Representing music at the level of a musical
score, as opposed to a performance as do audio files such as
MP3, they allow compositions to be manipulated in ways creative musicians
do&mdash;orchestrated, assigned to different instruments, transposed
to different keys, and adjusted in tempo, just to name a few.
Most musicians work on MIDI files using special-purpose music
editing programs called (for historical reasons) <em>sequencers</em>.
These programs are ideally suited for capturing music as it is played
and editing it into a final composition, but often lack the ability to
easily apply transformations in bulk to large collections of music
files (for example, changing instrument assignments for a set
of files from those of one studio to another), algorithmically
transforming music, or programmatically generating new music.

</p>

<p class="j">
MIDI files are stored in a compact binary form intended to
optimise speed (and hence reduce latency) on limited speed MIDI
channels, while not overly taxing the processing power of the
humble microcontrollers employed by instruments in the epoch
when MIDI was developed.  While well-suited to its intended
purposes, MIDI files are somewhat difficult to read and write
without a special-purpose library, particularly in commonly
used text processing languages such as
<a href="http://www.perl.org/" target="_blank">Perl</a>
and
<a href="http://www.python.org/" target="_blank">Python</a>
which are otherwise ideally suited to the kinds of
transformations one often wishes to apply to MIDI-encoded music.
</p>

<p class="j">
The <b>midicsv</b> and <b>csvmidi</b> programs allow you to use text
processing tools to transform MIDI files or create them from scratch. 

<b>midicsv</b> converts a MIDI file into a Comma-Separated Value (CSV)
text file, preserving all the information in the original MIDI file. 
The format of the CSV file is deliberately designed to facilitate
processing by text manipulation tools.  The <b>csvmidi</b> program
reads CSV files in this format and creates an equivalent MIDI file. 
Processing a MIDI file through <b>midicsv</b> and then <b>csvmidi</b>
will result in a completely equivalent (although, for technical
reasons relating to options in MIDI file compression, not necessarily
byte-for-byte identical) MIDI file.
</p>

<h2>MIDICSV Morsels</h2>

<p class="j">
Odds are, if these utilities are what you're looking for, you've already
thought of half a dozen ways to apply them to MIDI file
manipulation.  The following examples show how easy it is to
transform MIDI files once they're expressed in CSV format.  All
of these examples are written in the
<a href="http://www.perl.org/" target="_blank">Perl</a> language; it's
well suited to tasks of this type and it's the tool I reach for when
faced with such problems.  Any other language with comparable facilities
for text manipulation is equally applicable.  Source code for all of
these Perl programs is included in the <b>midicsv</b> distribution.
In the interest of brevity, I've elided comments in the program listings
below and moved discussion to text preceding each example.
If you don't have a hardware MIDI synthesiser, you can play MIDI files
on most computers with the
<a href="http://timidity.sourceforge.net/" target="_blank">TiMidity++</a>
software synthesiser, which can also create wave audio files from
MIDI songs.
</p>

<h3>Transpose Key &nbsp; &nbsp; (<tt>transpose.pl</tt>)</h3>

<p class="j">
All note events in the MIDI files, except those on channel 9, which
the General MIDI standard dedicates to percussion, are shifted by the
<tt>$offset</tt>, set in this example to &minus;12, hence one octave lower.
The Perl program simply filters the CSV representation of the MIDI file
looking for note-on and note-off events.  It excludes those for
channel 9 (percussion), then applies the offset to the note number
of the remaining events.  This program might be used to transform
a MIDI file with a pipeline like:
</p>

<pre>
    midicsv song.mid | perl transpose.pl | csvmidi &gt;tsong.mid
</pre>

<blockquote class="listing">
<pre>
    $offset = -12;
    $percussion = 9;

    while ($a = &lt;&gt;) {
        if ($a =~ s/(\d+,\s*\d+,\s*Note_\w+,\s*(\d+),\s*)(\d+)//) {
            $n = $3;
            if ($2 != $percussion) {
                $n += $offset;
            }
            if ($n &lt; 0) {
                next;
            }
            $a = "$1$n$a";
        }
        print($a);
    }

</pre>
</blockquote>

<h3>Chorus &nbsp; &nbsp; (<tt>chorus.pl</tt>)</h3>

<p class="j">
All note events in the MIDI files, except those on channel 9, which
the General MIDI standard dedicates to percussion, are duplicated with the
<tt>$offset</tt>, set in this example to &minus;12, hence one octave lower.
This is very similar to the transposition example above, but instead of
replacing notes by offset notes, adds simultaneously sounded offset
notes.  When used with a negative <tt>$offset</tt> of one or more
octave, this &ldquo;fattens&rdquo; the bass of a composition.  Try it!
This program may be used to transform
a MIDI file with a pipeline like:

</p>

<pre>
    midicsv song.mid | perl chorus.pl | csvmidi &gt;tsong.mid
</pre>

<blockquote class="listing">
<pre>
    $offset = -12;
    $percussion = 9;

    while ($a = &lt;&gt;) {
        print($a);
        if ($a =~ s/(\d+,\s*\d+,\s*Note_\w+,\s*(\d+),\s*)(\d+)//) {
            if ($2 != $percussion) {
                $n = $3;
                $n += $offset;
                if ($n &lt; 0) {
                    next;
                }
                $a = "$1$n$a";
                print($a);
            }
        }
    }
</pre>
</blockquote>

<h3>Extract Channel &nbsp; &nbsp; (<tt>exchannel.pl</tt>)</h3>

<p class="j">
Here's a program which extracts all MIDI events pertaining
to a given channel (<tt>$which_channel</tt> in the program below),
passing through the rest of the MIDI file structure.  With
<tt>$which_channel</tt> set to 9, as in this example, this
program will extract the percussion track from a General MIDI
file.  You can run this program with a pipeline such as:

</p>

<pre>
    midicsv song.mid | perl exchannel.pl | csvmidi &gt;tsong.mid
</pre>

<blockquote class="listing">
<pre>
    $which_channel = 9;
    
    while ($a = &lt;&gt;) {
    	if (!($a =~ m/\s*[\#\;]/)) { 	# Ignore comment lines
	    if ($a =~ m/\s*\d+\s*,\s*\d+\s*,\s*\w+_c\s*,\s*(\d+)/) {
    	    	if ($1 == $which_channel) {
		    print($a);
		}
	    } else {
	    	print($a);
	    }
        }
    }
</pre>
</blockquote>

<h3>Dumbest Drummer&nbsp; &nbsp; (<tt>drummer.pl</tt>)</h3>

<p class="j">
This is about the simplest drum machine imaginable.  You define
a rudimentary rhythm track in an Perl array, then call the
<tt>&amp;loop</tt> function to play it a given number of
times.  It's so simpleminded, it doesn't even allow overlap of
percussion hits&mdash;each note ends before the next sounds.  A
percussion note of 0 denotes a rest.  This example includes the
<b>general_midi.pl</b> file, included in the distribution,
which defines two hashes that allow you to specify General MIDI
patches (programs/instruments) and percussion note numbers by
name.  To run this program and create a ready-to-play MIDI
file, use the pipeline:
</p>

<pre>
    perl drummer.pl | csvmidi &gt;drumtrack.mid
</pre>

<blockquote class="listing">
<pre>

    require 'general_midi.pl';

#   	   Repeats, Note,
#   	      Duration, Velocity
    @track = (4, $GM_Percussion{'Acoustic Bass Drum'},
    	    	  480, 127,
    	      4, $GM_Percussion{'Low-Mid Tom'},
	          240, 127,
	      1, 0, 120, 0,
	      2,  $GM_Percussion{'Hand Clap'},
	      	  240, 127,
	      1, 0, 240, 0
	     );

    print &lt;&lt; "EOD";
0, 0, Header, 1, 1, 480
1, 0, Start_track
1, 0, Tempo, 500000
EOD

    $time = 0;
    
    &amp;loop(4, @track);
        
    print &lt;&lt; "EOD";
1, $time, End_track
0, 0, End_of_file
EOD

    sub note {	# &amp;note($note_number, $duration [, $velocity])
    	local ($which, $duration, $vel) = @_;
	
	if ($which &gt; 0) {
	    if (!defined($vel)) {
	    	$vel = 127;
	    }
    	    print("1, $time, Note_on_c, 9, $which, $vel\n");
	}
	$time += $duration;
	if ($which &gt; 0) {
    	    print("1, $time, Note_off_c, 9, $which, 0\n");
	}
    }
    
    sub loop {	# &amp;loop($ntimes, @track)	    
    	local ($loops, @tr) = @_;
	local ($i, $r);

    	for ($i = 0; $i &lt; $loops; $i++) {
	    local @t = @tr;
	    while ($#t &gt; 0) {
    		local ($repeats, $note, $duration, $velocity) =
		    splice(@t, 0, 4);
		for ($r = 0; $r &lt; $repeats; $r++) {
		    &amp;note($note, $duration, $velocity);
		}
	    }
	}
    }

</pre>
</blockquote>

<h3>Stoned Guitarist&nbsp; &nbsp; (<tt>acomp.pl</tt>)</h3>

<p class="j">
Finally, we have this dumb-as-a-bag-of-hair algorithmic composer which
simulates an around the bend musician noodling on an electric guitar. 
There's accompaniment by a cymbal, and a cymbal crash and utterly
unwarranted applause at the end.  This program isn't presented for its
musical merit, but simply to illustrate how easy it is to generate
arbitrary MIDI music files by writing CSV which is fed through
<b>csvmidi</b>.  This example also uses the definitions in the
<b>general_midi.pl</b>.  It may be run as follows:

</p>

<pre>
    perl acomp.pl | csvmidi &gt;performance.mid
</pre>

<blockquote class="listing">
<pre>
    require 'general_midi.pl';

    $instrument = $GM_Patch{'Distortion Guitar'};
    $tonespan = 32;
    $num_notes = 120;
    $percussion = $GM_Percussion{'Ride Cymbal 1'};
    $beat = 6;

    print &lt;&lt; "EOD";
0, 0, Header, 1, 1, 480
1, 0, Start_track
1, 0, Tempo, 500000
1, 0, Program_c, 1, $instrument
EOD

    $time = 0;
    srand(time());
    
    for ($i = 0; $i &lt; $num_notes; $i++) {
    	$n = 60 + int((rand() * $tonespan) - int($tonespan / 2));
    	$notelength = 120 + (60 * int(rand() * 6));
	&amp;note(1, $n, $notelength, 127);
	if (($i % $beat) == 0) {
	    print("1, $time, Note_on_c, 9, $percussion, 127\n");
	} elsif (($i % $beat) == ($beat - 1)) {
	    print("1, $time, Note_off_c, 9, $percussion, 0\n");
	}
    }
    
    #	Cymbal crash at end
    $cymbal = $GM_Percussion{'Crash Cymbal 2'};
    print("1, $time, Note_on_c, 9, $cymbal, 127\n");
    $time += 480;
    print("1, $time, Note_off_c, 9, $cymbal, 0\n");
    
    #	Audience applause
    $time += 480;
    print("1, $time, Program_c, 1, $GM_Patch{'Applause'}\n");     
    print("1, $time, Note_on_c, 1, 60, 100\n");
    for ($i = 16; $i &lt;= 32; $i++) {
    	$time += 120;
	$v = int(127 * ($i / 32));
	print("1, $time, Poly_aftertouch_c, 1, 60, $v\n");
    }
    for ($i = 32; $i &gt;= 0; $i--) {
    	$time += 240;
	$v = int(127 * ($i / 32));
	print("1, $time, Poly_aftertouch_c, 1, 60, $v\n");
    }
    print("1, $time, Note_off_c, 1, 60, 0\n");
   
    print &lt;&lt; "EOD";
1, $time, End_track
0, 0, End_of_file
EOD

    # &amp;note($channel, $note_number, $duration [, $velocity])
    sub note {
    	local ($channel, $which, $duration, $vel) = @_;
	
	if (!defined($vel)) {
	    $vel = 127;
	}
    	print("1, $time, Note_on_c, $channel, $which, $vel\n");
	$time += $duration;
    	print("1, $time, Note_off_c, $channel, $which, 0\n");
    }

</pre>
</blockquote>

<h2><a name="Download" href="midicsv-1.1.tar.gz"><img src="/images/icons/file.gif"
    alt="" align="middle" border="0" width="40"
    height="40" /></a> <a href="midicsv-1.1.tar.gz">Download midicsv-1.1.tar.gz</a> (Gzipped TAR archive)</h2>

<p class="j">
The archive contains source code for the utilities, a Makefile
for Unix systems, and ready-to-run executables for 32-bit
Windows platforms.  If you require only the Windows executables,
you can download a
<a href="midicsv-1.1.zip">Zipped archive</a>
containing just those files.
</p>

<h2>Manual Pages</h2>

<!--
        	       _     _ _                _ 
	     _ __ ___ (_) __| (_) ___ _____   _/ |
	    | '_ ` _ \| |/ _` | |/ __/ __\ \ / / |
	    | | | | | | | (_| | | (__\__ \\ V /| |
	    |_| |_| |_|_|\__,_|_|\___|___/ \_(_)_|

-->

<div style="background-color: rgb(255, 255, 176); font-size: smaller; padding-left: 1em; padding-right: 1em; padding-top:0.1ex; padding-bottom: 2ex;">

<h1 align="center"><a name="midicsv.1" class="i">midicsv</a></h1>

<h2>NAME</h2>

midicsv - translate MIDI file to CSV

<h2>SYNOPSIS</h2>

<b>midicsv</b>

[
<b>-u</b>
<b>-v</b>
] [
<i>infile</i>
[
<i>outfile</i>
] ]

<h2>DESCRIPTION</h2>

<p class="j">
<b>midicsv</b> reads a standard MIDI file and decodes it into a CSV
(Comma-Separated Value) file which preserves all the information in
the MIDI file.  The ASCII CSV file may be loaded into a spreadsheet or
database application, or processed by a program to transform the MIDI
data (for example, to key transpose a composition or extract a track
from a multi-track sequence).  A CSV file in the format created by

<b>midicsv</b> may be converted back into a standard MIDI file with
the <b>csvmidi</b> program.
</p>

<h2>OPTIONS</h2>

<dl>

<dt><b>-u</b></dt>
<dd>
Print how-to-call information.</dd>

<dt><b>-v</b></dt>
<dd>
Print verbose debugging information on standard error.  The MIDI file
header is dumped, along with the length of each track in the file.
</dd>
</dl>

<h2>FILES</h2>

<p class="j">
If no <i>infile</i> is specified or <i>infile</i> is

&ldquo;<b>-</b>&rdquo;, <b>midicsv</b> reads its input from standard
input; if no <i>outfile</i> is given or <i>outfile</i> is
&ldquo;<b>-</b>&rdquo;, CSV output is written  to standard output. 
The input and output are processed in a strictly serial manner;
consequently <b>midicsv</b> may be used in pipelines without
restrictions.
</p>

<h2>BUGS</h2>

<p class="j">
<b>midicsv</b> assumes its input is a well-formed standard MIDI file;
while some error checking is performed, gross errors in the input file
may cause <b>midicsv</b> to crash.
</p>

<p class="j">
Please report problems to bugs&nbsp;<b>at</b>&nbsp;fourmilab.ch.

</p>

<h2>SEE ALSO</h2>

<b><a href="#csvmidi.1">csvmidi</a></b>(1),
<b><a href="#midicsv.5">midicsv</a></b>(5)

</div>


<!--
                        	      _     _ _   _ 
	      ___ _____   ___ __ ___ (_) __| (_) / |
	     / __/ __\ \ / / '_ ` _ \| |/ _` | | | |
	    | (__\__ \\ V /| | | | | | | (_| | |_| |
	     \___|___/ \_/ |_| |_| |_|_|\__,_|_(_)_|

-->

<p />

<div style="background-color: rgb(176, 255, 176); font-size: smaller; padding-left: 1em; padding-right: 1em; padding-top:0.1ex; padding-bottom: 2ex;">

<h1 align="center"><a name="csvmidi.1" class="i">csvmidi</a></h1>

<h2>NAME</h2>

csvmidi - encode CSV file as MIDI

<h2>SYNOPSIS</h2>

<b>csvmidi</b>
[
<b>-u</b>
<b>-v</b>

<b>-x</b>
<b>-z</b>
] [
<i>infile</i>
[
<i>outfile</i>
] ]

<h2>DESCRIPTION</h2>

<p class="j">
<b>csvmidi</b> reads a CSV (Comma-Separated Value) file in the format
written by <b>midicsv</b> and creates the equivalent standard MIDI
file.

</p>

<h2>OPTIONS</h2>

<dl>

<dt><b>-u</b></dt>
<dd>
Print how-to-call information.
</dd>

<dt><b>-v</b></dt>
<dd>
Print verbose debugging information on standard
error.  The MIDI file header is dumped, along
with the length of each track in the file.

</dd>

<dt><b>-x</b></dt>
<dd>
MIDI streams support a rudimentary form of compression in which
successive events with the same &ldquo;status&rdquo; (event type and
channel) may omit the status byte. By default <b>csvmidi</b> avails
itself of this compression. If the <b>-x</b> option is specified, the
status byte is emitted for all events&mdash;it is never compressed
even when the MIDI standard permits it to be.
</dd>

<dt><b>-z</b></dt>
<dd>
Most errors detected in CSV records cause a warning message to be
displayed on standard error and the record ignored.  The <b>-z</b>
option causes <b>csvmidi</b> to immediately terminate processing when
the first error is detected.
</dd>
</dl>

<h2>EXIT STATUS</h2>

<p class="j">
If no errors or warnings are detected <b>csvmidi</b> exits with status
0.  A status of of 1 is returned if one or more errors were detected
in the CSV input file, while a status of 2 indicates a syntax error on
the command line or inability to open the input or output file.
</p>

<h2>FILES</h2>

<p class="j">
If no <i>infile</i> is specified or <i>infile</i> is

&ldquo;<b>-</b>&rdquo;, <b>csvmidi</b> reads its input from standard
input; if no <i>outfile</i> is given or <i>outfile</i> is
&ldquo;<b>-</b>&rdquo;, MIDI output is written  to standard output. 
The input and output are processed in a strictly serial manner;
consequently <b>csvmidi</b> may be used in pipelines without
restrictions.
</p>

<h2>BUGS</h2>

<p class="j">
<b>csvmidi</b> assumes its input is in the format written by
<b>midicsv</b>. If supplied a CSV file with well-formed records which
nonetheless makes no semantic sense as a MIDI file, the results will,
in all likelihood, simply perplex any program or instrument to which
it's sent. <b>csvmidi</b> checks for missing fields and range checks
all numeric values, but does not perform higher-level consistency
checking (for example, making sure that every note on event is paired
with a subsequent note off).  That level of verification, if required,
should be done on the CSV file before it is processed by
<b>csvmidi</b>.
</p>

<p class="j">
Exporting a file to CSV with <b>midicsv</b> and then importing it with
<b>csvmidi</b> is not guaranteed to create an identical MIDI file. 
MIDI files support compression modes which are not obligatory. A MIDI
file exported to CSV and then re-imported should, however, be
<i>equivalent</i> to the original file and should, if exported to CSV,
be identical to the CSV exported from the original file.
</p>

<p class="j">
Please report problems to bugs&nbsp;<b>at</b>&nbsp;fourmilab.ch.

</p>

<h2>SEE ALSO</h2>

<b><a href="#midicsv.1">midicsv</a></b>(1),
<b><a href="#midicsv.5">midicsv</a></b>(5)

</div>


<!--
        	       _     _ _                ____  
	     _ __ ___ (_) __| (_) ___ _____   _| ___| 
	    | '_ ` _ \| |/ _` | |/ __/ __\ \ / /___ \ 
	    | | | | | | | (_| | | (__\__ \\ V / ___) |
	    |_| |_| |_|_|\__,_|_|\___|___/ \_(_)____/ 

-->

<p />

<div style="background-color: rgb(176, 176, 255); font-size: smaller; padding-left: 1em; padding-right: 1em; padding-top:0.1ex; padding-bottom: 2ex;">

<h1 align="center"><a name="midicsv.5" class="i">midicsv File Format</a></h1>

<h2>NAME</h2>

midicsv - MIDI Comma-Separated Value (CSV) file format

<h2>DESCRIPTION</h2>

<p class="j">
The <b>midicsv</b> and <b>csvmidi</b> programs permit you to
intertranslate standard MIDI files and comma-separated value (CSV)
files.  These CSV files preserve all information in the MIDI file, and
may be loaded into spreadsheet and database programs or easily
manipulated with text processing tools. This document describes the
CSV representation of MIDI files written by <b>midicsv</b> and read by

<b>csvmidi</b>. Readers are assumed to understand the structure,
terminology, and contents of MIDI files&mdash;please refer to a MIDI
file reference for details.
</p>

<h2>RECORD STRUCTURE</h2>

<p class="j">
Each record in the CSV representation of a MIDI contains at least
three fields:
</p>

<dl>

<dt><b>Track</b></dt>
<dd>

Numeric field identifying the track to which this record belongs. 
Tracks of MIDI data are numbered starting at 1.  Track 0 is reserved
for file header, information, and end of file records.
</dd>

<dt><b>Time</b></dt>
<dd>
Absolute time, in terms of MIDI clocks, at which this event occurs. 
Meta-events for which time is not meaningful (for example, song title,
copyright information, etc.) have an absolute time of 0.
</dd>

<dt><b>Type</b></dt>
<dd>
Name identifying the type of the record.  Record types are text
consisting of upper and lower case letters and the underscore
(&ldquo;_&rdquo;), contain no embedded spaces, and are not enclosed in
quotes. <b>csvmidi</b> ignores upper/lower case in the <b>Type</b>

field; the specifications &ldquo;<b>Note_on_c</b>&rdquo;,
&ldquo;<b>Note_On_C</b>&rdquo;, and &ldquo;<b>NOTE_ON_C</b>&rdquo; are
considered identical.
</dd>

</dl>

<p class="j">
Records in the CSV file are sorted first by the track number, then by
time.  Out of order records will be discarded with an error message
from <b>csvmidi</b>. Following the three required fields are parameter
fields which depend upon the <b>Type</b>; some <b>Type</b>s take no
parameters.  Each <b>Type</b> and its parameter fields is discussed
below.

</p>

<p class="j">
Any line with an initial nonblank character of &ldquo;<b>#</b>&rdquo;
or &ldquo;<b>;</b>&rdquo; is ignored; either delimiter may be used to
introduce comments in a CSV file.  Only full-line comments are
permitted; you cannot use these delimiters to terminate scanning of a
regular data record.  Completely blank lines are ignored.
</p>

<h3>File Structure Records</h3>

<dl>

<dt><b>0, 0, Header</b><i>, format, nTracks, division</i></dt>
<dd>
The first record of a CSV MIDI file is always the <b>Header</b>
record.  Parameters are <i>format</i>: the MIDI file type (0, 1, or
2), <i>nTracks</i>: the number of tracks in the file, and
<i>division</i>: the number of clock pulses per quarter note. The
<b>Track</b> and <b>Time</b> fields are always zero.

</dd>

<dt><b>0, 0, End_of_file</b></dt>
<dd>
The last record in a CSV MIDI file is always an <b>End_of_file</b>
record.  Its <b>Track</b> and <b>Time</b> fields are always zero.
</dd>

<dt><i>Track, </i><b>0, Start_track</b></dt>
<dd>
A <b>Start_track</b> record marks the start of a new track, with the
<i>Track</i> field giving the track number.  All records between the
<b>Start_track</b> record and the matching <b>End_track</b> will have
the same <i>Track</i> field.

</dd>

<dt><i>Track, Time, </i><b>End_track</b></dt>
<dd>
An <b>End_track</b> marks the end of events for the specified
<i>Track</i>. The <i>Time</i> field gives the total duration of the
track, which will be identical to the <i>Time</i> in the last event
before the <b>End_track</b>.

</dd>

</dl>

<h3>File Meta-Events</h3>

<p class="j">
The following events occur within MIDI tracks and specify various
kinds of information and actions.  They may appear at any time within
the track.  Those which provide general information for which time is
not relevant usually appear at the start of the track with <b>Time</b>
zero, but this is not a requirement.
</p>

<p class="j">
Many of these meta-events include a text string argument.  Text
strings are output in CSV records enclosed in ASCII double quote
(&quot;) characters.  Quote characters embedded within strings are
represented by two consecutive quotes. Non-graphic characters in the
ISO 8859-1 Latin-1 set are output as a backslash followed by their
three digit octal character code.  Two consecutive backslashes denote
a literal backslash in the string. Strings in MIDI files can be
extremely long, theoretically as many as 2<sup>28</sup>&minus;1
characters; programs which process MIDI CSV files should take care to
avoid buffer overflows or truncation resulting from lines containing
long string items.  All meta-events which take a text argument are
identified by a suffix of &ldquo;<b>_t</b>&rdquo;.

</p>

<dl>

<dt><i>Track, Time, </i><b>Title_t, </b><i>Text</i><b></b></dt>
<dd>
The <i>Text</i> specifies the title of the track or sequence.  The
first <b>Title</b> meta-event in a type 0 MIDI file, or in the first
track of a type 1 file gives the name of the work.  Subsequent
<b>Title</b> meta-events in other tracks give the names of those
tracks.

</dd>

<dt><i>Track, Time, </i><b>Copyright_t, </b><i>Text</i><b></b></dt>
<dd>
The <i>Text</i> specifies copyright information for the sequence. This
is usually placed at time 0 of the first track in the sequence.
</dd>

<dt><i>Track, Time, </i><b>Instrument_name_t, </b><i>Text</i><b></b></dt>

<dd>
The <i>Text</i> names the instrument intended to play the contents of
this track, This is usually placed at time 0 of the track.  Note that
this meta-event is simply a description; MIDI synthesisers are not
required (and rarely if ever) respond to it. This meta-event is
particularly useful in sequences prepared for synthesisers which do
not conform to the General MIDI patch set, as it documents the
intended instrument for the track when the sequence is used on a
synthesiser with a different patch set.
</dd>

<dt><i>Track, Time, </i><b>Marker_t, </b><i>Text</i><b></b></dt>
<dd>
The <i>Text</i> marks a point in the sequence which occurs at the
given <i>Time</i>, for example &quot;Third&nbsp;Movement&quot;.

</dd>

<dt><i>Track, Time, </i><b>Cue_point_t, </b><i>Text</i><b></b></dt>
<dd>
The <i>Text</i> identifies synchronisation point which occurs at the
specified <i>Time</i>, for example, &quot;Door&nbsp;slams&quot;.
</dd>

<dt><i>Track, Time, </i><b>Lyric_t, </b><i>Text</i><b></b></dt>
<dd>
The <i>Text</i> gives a lyric intended to be sung at the given
<i>Time</i>. Lyrics are often broken down into separate syllables to
time-align them more precisely with the sequence.
</dd>

<dt><i>Track, Time, </i><b>Text_t, </b><i>Text</i><b></b></dt>

<dd>
This meta-event supplies an arbitrary <i>Text</i> string tagged to the
<i>Track</i> and <i>Time</i>. It can be used for textual information
which doesn't fall into one of the more specific categories given
above.
</dd>

<dt><i>Track, </i><b>0, Sequence_number, </b><i>Number</i></dt>
<dd>

This meta-event specifies a sequence <i>Number</i> between 0 and
65535, used to arrange multiple tracks in a type 2 MIDI file, or to
identify the sequence in which a collection of type 0 or 1 MIDI files
should be played. The <b>Sequence_number</b> meta-event should occur
at <b>Time</b> zero, at the start of the track.
</dd>

<dt><i>Track, Time, </i><b>MIDI_port, </b><i>Number</i></dt>
<dd>

This meta-event specifies that subsequent events in the <b>Track</b>
should be sent to MIDI port (bus) <i>Number</i>, between 0 and 255.
This meta-event usually appears at the start of a track with
<b>Time</b> zero, but may appear within a track should the need arise
to change the port while the track is being played.
</dd>

<dt><i>Track, Time, </i><b>Channel_prefix, </b><i>Number</i></dt>
<dd>
This meta-event specifies the MIDI channel that subsequent meta-events
and <b>System_exclusive</b> events pertain to.  The channel

<i>Number</i> specifies a MIDI channel from 0 to 15.  In fact, the
<i>Number</i> may be as large as 255, but the consequences of
specifying a channel number greater than 15 are undefined.
</dd>

<dt><i>Track, Time, </i><b>Time_signature, </b><i>Num, Denom, Click, NotesQ</i></dt>
<dd>
The time signature, metronome click rate, and number of 32nd notes per
MIDI quarter note (24 MIDI clock times) are given by the numeric
arguments. <i>Num</i> gives the numerator of the time signature as
specified on sheet music. <i>Denom</i> specifies the denominator as a
negative power of two, for example 2 for a quarter note, 3 for an
eighth note, etc. <i>Click</i> gives the number of MIDI clocks per
metronome click, and <i>NotesQ</i> the number of 32nd notes in the
nominal MIDI quarter note time of 24 clocks (8 for the default MIDI
quarter note definition).

</dd>

<dt><i>Track, Time, </i><b>Key_signature, </b><i>Key, Major/Minor</i></dt>
<dd>
The key signature is specified by the numeric <i>Key</i> value, which
is 0 for the key of C, a positive value for each sharp above C, or a
negative value for each flat below C, thus in the inclusive range &minus;7
to 7.  The <i>Major/Minor</i> field is a quoted string which will be
<b>major</b> for a major key and <b>minor</b> for a minor key.

</dd>

<dt><i>Track, Time, </i><b>Tempo, </b><i>Number</i></dt>
<dd>
The tempo is specified as the <i>Number</i> of microseconds per
quarter note, between 1 and 16777215.  A value of 500000 corresponds
to 120 quarter notes (&ldquo;beats&rdquo;) per minute.  To convert beats
per minute to a <b>Tempo</b> <i>value</i>, take the quotient from
dividing 60,000,000 by the beats per minute.

</dd>

<dt><i>Track, </i><b>0, SMPTE_offset, </b><i>Hour, Minute, Second, Frame, FracFrame</i></dt>
<dd>
This meta-event, which must occur with a zero <b>Time</b> at the start
of a track, specifies the SMPTE time code at which it should start
playing.  The <i>FracFrame</i> field gives the fractional frame time
(0 to 99).
</dd>

<dt><i>Track, Time, </i><b>Sequencer_specific, </b><i>Length, Data, &hellip;</i></dt>

<dd>
The <b>Sequencer_specific</b> meta-event is used to store
vendor-proprietary data in a MIDI file.  The <i>Length</i> can be any
value between 0 and 2<sup>28</sup>&minus;1, specifying the number of
<i>Data</i> bytes (between 0 and 255) which follow.
<b>Sequencer_specific</b> records may be very long; programs which
process MIDI CSV files should be careful to protect against buffer
overflows and truncation of these records.
</dd>

<dt><i>Track, Time, </i><b>Unknown_meta_event, </b><i>Type, Length, Data, &hellip;</i></dt>
<dd>
If <b>midicsv</b> encounters a meta-event with a code not defined by
the standard MIDI file specification, it outputs an unknown meta-event
record in which <i>Type</i> gives the numeric meta-event type code,
<i>Length</i> the number of data bytes in the meta-event, which can be
any value between 0 and 2<sup>28</sup>&minus;1, followed by the

<i>Data</i> bytes.  Since meta-events include their own length, it is
possible to parse them even if their type and meaning are unknown.
<b>csvmidi</b> will reconstruct unknown meta-events with the same type
code and content as in the original MIDI file.
</dd>

</dl>

<h3>Channel Events</h3>

<p class="j">
These events are the &ldquo;meat and potatoes&rdquo; of MIDI files:
the actual notes and modifiers that command the instruments to play
the music.  Each has a MIDI channel number as its first argument,
followed by event-specific parameters.  To permit programs which
process CSV files to easily distinguish them from meta-events, names
of channel events all have a suffix of &ldquo;<b>_c</b>&rdquo;.

</p>

<dl>

<dt><i>Track, Time, </i><b>Note_on_c, </b><i>Channel, Note, Velocity</i></dt>
<dd>
Send a command to play the specified <i>Note</i> (Middle C is defined
as <i>Note</i> number 60; all other notes are relative in the MIDI
specification, but most instruments conform to the well-tempered
scale) on the given <i>Channel</i> with <i>Velocity</i> (0 to 127).  A

<b>Note_on_c</b> event with <i>Velocity</i> zero is equivalent to a
<b>Note_off_c</b>.
</dd>

<dt><i>Track, Time, </i><b>Note_off_c, </b><i>Channel, Note, Velocity</i></dt>
<dd>
Stop playing the specified <i>Note</i> on the given <i>Channel</i>.
The <i>Velocity</i> should be zero, but you never know what you'll
find in a MIDI file.

</dd>

<dt><i>Track, Time, </i><b>Pitch_bend_c, </b><i>Channel, Value</i></dt>
<dd>
Send a pitch bend command of the specified <i>Value</i> to the given
<i>Channel</i>. The pitch bend <i>Value</i> is a 14 bit unsigned
integer and hence must be in the inclusive range from 0 to 16383.
The value 8192 indicates no pitch bend; 0 the lowest pitch bend,
and 16383 the highest.  The actual change in pitch these values
produce is unspecified.
</dd>

<dt><i>Track, Time, </i><b>Control_c, </b><i>Channel, Control_num, Value</i></dt>
<dd>
Set the controller <i>Control_num</i> on the given <i>Channel</i> to
the specified <i>Value</i>. <i>Control_num</i> and <i>Value</i> must
be in the inclusive range 0 to 127.  The assignment of

<i>Control_num</i> values to effects differs from instrument to
instrument.  The General MIDI specification defines the meaning of
controllers 1 (modulation), 7 (volume), 10 (pan), 11 (expression), and
64 (sustain), but not all instruments and patches respond to these
controllers.  Instruments which support those capabilities usually
assign reverberation to controller 91 and chorus to controller 93.
</dd>

<dt><i>Track, Time, </i><b>Program_c, </b><i>Channel, Program_num</i></dt>
<dd>
Switch the specified <i>Channel</i> to program (patch)
<i>Program_num</i>, which must be between 0 and 127.  The program or
patch selects which instrument and associated settings that channel
will emulate. The General MIDI specification provides a standard set
of instruments, but synthesisers are free to implement other sets of
instruments and many permit the user to create custom patches and
assign them to program numbers.

<br />

<br />

Apparently, due to instrument manufacturers' skepticism about
musicians' ability to cope with the number zero, many instruments
number patches from 1 to 128 rather than the 0 to 127 used within MIDI
files.  When interpreting <i>Program_num</i> values, note that they
may be one less than the patch numbers given in an instrument's
documentation.
</dd>

<dt><i>Track, Time, </i><b>Channel_aftertouch_c, </b><i>Channel, Value</i></dt>
<dd>
When a key is held down after being pressed, some synthesisers send
the pressure, repeatedly if it varies, until the key is released, but
do not distinguish pressure on different keys played simultaneously
and held down.  This is referred to as &ldquo;monophonic&rdquo; or

&ldquo;channel&rdquo; aftertouch (the latter indicating it applies to
the <i>Channel</i> as a whole, not individual note numbers on that
channel).  The pressure <i>Value</i> (0 to 127) is typically taken to
apply to the last note played, but instruments are not guaranteed to
behave in this manner.
</dd>

<dt><i>Track, Time, </i><b>Poly_aftertouch_c, </b><i>Channel, Note, Value</i></dt>
<dd>
Polyphonic synthesisers (those capable of playing multiple notes
simultaneously on a single channel), often provide independent
aftertouch for each note.  This event specifies the aftertouch
pressure <i>Value</i> (0 to 127) for the specified <i>Note</i> on the
given <i>Channel</i>.

</dd>

</dl>

<h3>System Exclusive Events</h3>

<p class="j">
System Exclusive events permit storing vendor-specific
information to be transmitted to that vendor's products.
</p>

<dl>

<dt><i>Track, Time, </i><b>System_exclusive, </b><i>Length, Data, &hellip;</i></dt>

<dd>
The <i>Length</i> bytes of <i>Data</i> (0 to 255) are sent at the
specified <i>Time</i> to the MIDI channel defined by the most recent
<b>Channel_prefix</b> event on the <i>Track</i>, as a System Exclusive
message. Note that <i>Length</i> can be any value between 0 and
2<sup>28</sup>&minus;1. Programs which process MIDI CSV files should
be careful to protect against buffer overflows and truncation of these
records.

</dd>

<dt><i>Track, Time, </i><b>System_exclusive_packet, </b><i>Length, Data, &hellip;</i></dt>

<dd>
The <i>Length</i> bytes of <i>Data</i> (0 to 255) are sent at the
specified <i>Time</i> to the MIDI channel defined by the most recent

<b>Channel_prefix</b> event on the <i>Track</i>. The <i>Data</i> bytes
are simply blasted out to the MIDI bus without any prefix.  This
message is used by MIDI devices which break up long system exclusive
message into small packets, spaced out in time to avoid overdriving
their modest microcontrollers. Note that <i>Length</i> can be any
value between 0 and 2<sup>28</sup>&minus;1. Programs which process
MIDI CSV files should be careful to protect against buffer overflows
and truncation of these records.
</dd>

</dl>

<h2>EXAMPLES</h2>

<p class="j">
The following CSV file defines the five-note motif from the film
<i>Close Encounters of the Third Kind</i> using an organ patch from
the General MIDI instrument set.  When processed by <b>midicsv</b> and
sent to a synthesiser which conforms to General MIDI, the sequence
will be played.
</p>

<pre>
0, 0, Header, 1, 2, 480
1, 0, Start_track
1, 0, Title_t, &quot;Close Encounters&quot;

1, 0, Text_t, &quot;Sample for MIDIcsv Distribution&quot;
1, 0, Copyright_t, &quot;This file is in the public domain&quot;
1, 0, Time_signature, 4, 2, 24, 8
1, 0, Tempo, 500000
1, 0, End_track
2, 0, Start_track
2, 0, Instrument_name_t, &quot;Church Organ&quot;
2, 0, Program_c, 1, 19
2, 0, Note_on_c, 1, 79, 81
2, 960, Note_off_c, 1, 79, 0
2, 960, Note_on_c, 1, 81, 81
2, 1920, Note_off_c, 1, 81, 0
2, 1920, Note_on_c, 1, 77, 81
2, 2880, Note_off_c, 1, 77, 0
2, 2880, Note_on_c, 1, 65, 81
2, 3840, Note_off_c, 1, 65, 0
2, 3840, Note_on_c, 1, 72, 81
2, 4800, Note_off_c, 1, 72, 0
2, 4800, End_track
0, 0, End_of_file
</pre>

<h2>BUGS</h2>

<p class="j">
The CSV representation of a MIDI file is simply a text-oriented
encoding of its contents.  If the input to <b>midicsv</b> contains
errors which violate the MIDI standard, the resulting CSV file will
faithfully replicate these errors. Similarly, the CSV input to

<b>csvmidi</b> must not only consist of records which conform to the
syntax given in this document, the input as a whole must also be a
<i>semantically</i> correct MIDI file.  Programs which wish to use
<b>csvmidi</b> to generate MIDI files from scratch should be careful
to conform to the structure required of MIDI files.  When in doubt,
use <b>midicsv</b> to dump a sequence comparable to the one your
program will create and use its structure as a template for your own.
</p>

<p class="j">
Please report errors to bugs&nbsp;<b>at</b>&nbsp;fourmilab.ch.

</p>

<h2>SEE ALSO</h2>

<b><a href="#csvmidi.1">csvmidi</a></b>(1),
<b><a href="#midicsv.1">midicsv</a></b>(1)

</div>

<p />
<blockquote>
<p class="j">
     This software is in the public domain.  Permission to use, copy,
     modify, and distribute this software and its documentation for
     any purpose and without fee is hereby granted, without any
     conditions or restrictions.  This software is provided &ldquo;as
     is&rdquo; without express or implied warranty.

</p>
</blockquote>

<p />
<hr />
<p />
<address>
by <a href="/">John Walker</a><br />
February, 2004<br />
Revised January, 2008
</address>

<h3><a href="/">Fourmilab Home Page</a></h3>

</body>
</html>
